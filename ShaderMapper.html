<html>
	<head>
		<title>ShaderMapper</title>
		<style>
			body{
			    margin:0px;
				background-color:black;
			}	
			video{
				opacity: 1;
				width:100%;
				height:100%;
				top:0px;
				left:0px;
				z-index:-1;
				transform:scale(-1,1);
				position:fixed;
				float:left;
				object-fit:fill;
			}
			canvas{
				opacity: 1;
				width:100%;
				height:100%;
				top:0px;
				left:0px;
				z-index:10;
				transform:scale(1,1);
				position:fixed;
				float:left;
				object-fit:fill;
				/* cursor: none; */
			}
			textarea{
				z-index:100;
				position:fixed;
				height:42.5%;
				width:35%;
				background-color: grey;
				border-color: #515151;
				border-width:4;
				border-top-width:8;
				border-left-width:8;
				border-right-width:8;
				font-size: 14px;
				wrap: off;
				white-space: nowrap;
			}
			#show_shader_editor{
				z-index:100;
				position:fixed;
				left:0px;
				top:0px;
				height:6%;
				width:100px;
				background-color: darkgrey;
				border-color: #515151;
				border-width:4;
				border-top-width:0;
				border-left-width:0;
				font-size: 14px;
			}
			#hide_shader_editor{
				z-index:100;
				position:fixed;
				left:0px;
				bottom:0px;
				height:15%;
				width:10%;
				background-color: darkgrey;
				border-color: #515151;
				border-width:4;
				border-left-width:8;
				border-bottom-width:8;
				font-size: 18px;
			}
			#update_shader_button{
				z-index:100;
				position:fixed;
				left:10%;
				bottom:0px;
				height:15%;
				width:25%;
				background-color: darkgrey;
				border-color: #515151;
				border-width:4;
				border-right-width:8;
				border-bottom-width:8;
				font-size: 24px;
			}
			#update_shader_button:active{
				background-color: grey;			
			}
			video{
				opacity: 1;
				width:100%;
				height:100%;
				top:0px;
				left:0px;
				z-index:-1;
				transform:scale(-1,1);
				position:fixed;
				float:left;
				object-fit:fill;
			}
		</style>
	</head>
	<body>
		<script src="dependancies/three.js"></script>
		<script src="dependancies/pixel8.js"></script>
		<script src="dependancies/dat.gui.min.js"></script>
		<script src="dependancies/Detector.js"></script>
		<script src="dependancies/NURBSSurface.js"></script>
		<script src="dependancies/NURBSUtils.js"></script>
		<script src="dependancies/TrackballControls.js"></script> 

		<video id="video" autoplay width='256' height='256' style="display:none;"></video>
		<canvas id="maskCanvas"  width='256' height='256' style="display:none; z-index:11; "></canvas>

		<script id="vertexShader" type="x-shader/x-vertex">
precision mediump float;
precision mediump int;

uniform mat4 modelViewMatrix; // optional
uniform mat4 projectionMatrix; // optional

attribute vec3 position;
attribute vec4 color;
attribute vec2 uv;

varying vec3 vPosition;
varying vec4 vColor;
varying vec2 vUv;

void main()	{
	vUv = uv;
	vPosition = position;
	vColor = color;

	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

}
		</script>

		<script id="fragmentShader1" type="x-shader/x-fragment">
			precision mediump float;
			precision mediump int;
			
			uniform float time;
			varying vec2 vUv;
			uniform sampler2D maskTexture;
			uniform sampler2D maskTexture2;
			
			void main( void ) {
			
				vec2 position = -1.0+2.*vUv;
					position=position*position*vec2(-1.0, 1.0)+ vec2(2.5, 2.5);
			
				float color = 0.0;
				color += sin( position.x * cos( time / 55.0 ) * 80.0 ) + cos( position.y * cos( time / 15.0 ) * 10.0 );
				color += sin( position.y * sin( time / 100.0 ) * 40.0 ) + cos( position.x * sin( time / 45.0 ) * 40.0 );
				color += sin( position.x * sin( time / 25.0 ) * 10.0 ) + sin( position.y * sin( time / 35.0 ) * 30.0 );
				color *= sin( time / 500.0 ) * 1.5;
				vec3 mask = texture2D( maskTexture, vUv ).rgb;
				gl_FragColor = vec4( vec3(  color * 4.2,6.2*(1.-color),color * 12.0 ), mask.r );
			
			}			
		</script>
		
		 <script id="fragmentShader2" type="x-shader/x-fragment">
	precision mediump float;
	precision mediump int;
	
	uniform float time;
	varying vec2 vUv;
	uniform sampler2D maskTexture;
	uniform sampler2D maskTexture2;
	
	void main()	{
		vec2 position = - 3.0 + 6.0 * vUv;
		float red = abs( sin( position.x * position.y - time / 2.0 ) );
		float green = abs( sin( position.x * position.y + time / 4.0 ) );
		float blue = abs( sin( position.x * position.y + time / 3.0 ) );
		vec3 mask = texture2D( maskTexture, vUv ).rgb;
		gl_FragColor = vec4( mask.r*red*.7, mask.g*green-.7, mask.b*blue*1.2, mask.r );
	}
		</script>

		<script>
			initGlobalVars();

			function watchForMask7ImageUpdates(){
				var xmlhttp=new XMLHttpRequest();
				xmlhttp.open("GET", "php/read.php?fn=globalPresets/imageMaskNeedsUpdate.txt", true);
				xmlhttp.send();
				xmlhttp.onload = function(e){
					if(xmlhttp.response.indexOf("true")!=-1){
						if(globalController.MaskA==7){
							uniforms1.maskTexture={ value: new THREE.TextureLoader().load( 'masks/mask7.jpg' ) };
						}
						if(globalController.MaskB==7){
							uniforms2.maskTexture={ value: new THREE.TextureLoader().load( 'masks/mask7.jpg' ) };
						}
						mask7UpdateNumber=mask7UpdateNumber+1;
						resetImageMaskNeedsUpdate();
					}
					setTimeout(function(){
						watchForMask7ImageUpdates();
					},10000);
				}
			}

			function resetImageMaskNeedsUpdate(){
				var requestBody="false";
				var xmlhttp=new XMLHttpRequest();
				xmlhttp.open("POST", "php/write.php?fn=globalPresets/imageMaskNeedsUpdate.txt", true);
				xmlhttp.send(requestBody);
				xmlhttp.onload = function(e){
					console.log("Reset imageMaskNeedsUpdate")
				}
			}

			function initGlobalVars(){
				mask7UpdateNumber=0;
				haveChangedLocalSettingsInControllerMode=true;
				lastObjectVerticeData="";
				maskControllerScalingFactor=1.5;
				haveDrawnMaskHandles=false;
				isMaskMode=false;
				maskHandleObjects=[];
				maskHandleState=[];
				numMaskHandles=12;
				mouseLastMovedTime=new Date().getTime();
				setInterval(function(){
					if( ( (new Date().getTime())-mouseLastMovedTime ) > 5000 ){
						renderer.domElement.style.cursor = "none";
					}
				},4000);
				setCurrentApp("sm");
				checkForForceInitControllerMode();
				slaveModeInterval=-1;
				controllerModeInterval=-1;
				getCanvasYFlip();
				getNumberOfShadersAndPresets();
				audioData = new Uint8Array(8);
				//------------------
				ledStripAnimationmMasterIndex=0;
				ledStripPatternsArray=[];
				getDMXPatternData(1,ledStripPatternsArray);
				//------------------
				initAudio();
				setTimeout(function(){
					setInterval(function(){  
						audioVolume=audioData.reduce(function(a, b){return a + b;}, 0)/1024/100; 
						if(audioVolume>globalController.VolumeThreshold){
							uniforms1.audioVolume={ value: ((uniforms1.audioVolume.value+.001+audioVolume*400.0)%1.0) };
							uniforms2.audioVolume={ value: ((uniforms2.audioVolume.value+.001+audioVolume*400.0)%1.0) };

							ledStripAnimationmMasterIndex=(ledStripAnimationmMasterIndex+5)%(ledStripPatternsArray[parseInt(globalController.DMX_Pattern)-1].length-1);

							//console.log(audioVolume);
							globalController.DMX_Scene=(globalController.DMX_Scene+.3)%maxNumDMXScenes;
						}else{
							ledStripAnimationmMasterIndex=(ledStripAnimationmMasterIndex+globalController.DMX_Pattern_Rate)%(ledStripPatternsArray[parseInt(globalController.DMX_Pattern)-1].length-1);
						}
					} ,100);
				}, 2000);
				//------------------
				lastMaskAValue=-1;
				lastMaskBValue=-1;
				fade_Position=0;
				setTimeout(function(){recallState();loadShaderPreset(1);loadShaderPreset(2);},10);
				addControls();
				gui.close();
				dmxInterval=0;
				maxNumDMXScenes=8;
				dmxPresetData=[];
				initializeDMX();
				selectedVertice=0;
				selectedMaskHandle=0;
				// width=document.getElementById('video').width;
				// height=document.getElementById('video').height;	
				width=32;
				height=32;
				materialArray=new Uint8Array(width * height * 4);
				// previousData=new Uint8Array(width * height * 4);
				// data=new Uint8Array(width * height * 4);
				isFirstCycle=true;
				colorCounter=0.0;
				container=null;
				camera=null;
				controls=null;
				scene=null;
				renderer=null;
				objects = [];
				displayObjects=[];
				plane = new THREE.Plane();
				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2();
				offset = new THREE.Vector3();
				intersection = new THREE.Vector3();
				INTERSECTED=null;
				SELECTED=null;
				initScene();
				animate();
				statesArray=[];
				for(var x=0;x<4;x++){
					var objectJSON ={}
					for (var key in objectController) {
						objectJSON[key]=objectController[key]
					}
					statesArray.push(objectJSON)
				}
				for(var y=0;y<4;y++){
					addObject();
				}
				statesArray[0].Visible=true;
				//=------
				globalState={};
				for (var key in globalController) {
					globalState[key]=globalController[key]
				}
				//=------
				drawMaskHandles();
				updateControlsView();
				syncObjectsToJson();
				window.addEventListener("keypress", keyHandler);
				highlightSelectedVertice();
				highlightSelectedMaskHandle();
				dataTex = new THREE.DataTexture(new Uint8Array(256 * 256 * 3), 256, 256);
				setTimeout(function(){watchForMask7ImageUpdates();},1000);
				// setTimeout(function(){document.getElementById('maskCanvas').style.transform="scale(-1,1)"; changeMask(3); },4000);
			}
			
			function drawMaskHandles(){

				for(x=0;x<numMaskHandles;x++){

					maskHandleState.push({"x":0,"y":0});
					var circle = new THREE.Mesh( new THREE.CircleGeometry(20, 20, 0, Math.PI * 2 ), new THREE.MeshPhongMaterial({side: THREE.DoubleSide, color:0xffffff}));
					circle.name="maskHandle"+x;
					circle.num=x;
					circle.visible=true;
					scene2.add(circle);
					objects.push(circle);
					maskHandleObjects.push(circle);
				}

				maskHandleLinesMaterial = new THREE.LineBasicMaterial( { color: 0x00ffff, linewidth: 1 } );
				maskHandleLinesGeometry = new THREE.BufferGeometry();
				var maskHandleLinesPositions = new Float32Array( numMaskHandles * 3 + 1*3 ); // 3 vertices per point
				maskHandleLinesGeometry.addAttribute( 'position', new THREE.BufferAttribute( maskHandleLinesPositions, 3 ) );
				maskHandleLinesGeometry.setDrawRange( 0, numMaskHandles + 1 );
				maskHandleLinesObject = new THREE.Line( maskHandleLinesGeometry, maskHandleLinesMaterial );
				maskHandleLinesObject.position.z=20
				scene2.add(maskHandleLinesObject);	

				haveDrawnMaskHandles=true;
			}

			function toggleMaskMode(modeString){
				if(modeString=="mask"){
					isMaskMode=true;
					scene=scene2;
				}
				if(modeString=="map"){
					isMaskMode=false;
					scene=scene1;
					syncObjectsToJson();
				}
			}

			function updateShader(){
				document.getElementById( 'fragmentShader'+parseInt(globalController.shaderToEdit)).textContent=document.getElementById('frag_shader_text_box').value
				document.getElementById( 'vertexShader' ).textContent=document.getElementById('vertex_shader_text_box').value
				materialsList=initShaderMaterial(uniforms1);
				for(var i=0;i<displayObjects.length;i++){
					if(statesArray[i].Visible==true){
						displayObjects[i].material=materialsList[statesArray[i].Shader-1]
					}
				}
				syncObjectsToJson();
			}
			
			function initShaderMaterial(uniforms1){

				matList=[];
				for(var x=1;x<=2;x++){
					if(x==1){
						var material = new THREE.RawShaderMaterial( {
							uniforms: uniforms1,
							vertexShader: document.getElementById( 'vertexShader' ).textContent,
							fragmentShader: document.getElementById( 'fragmentShader'+x ).textContent
						} );	
					}else{
						var material = new THREE.RawShaderMaterial( {
							uniforms: uniforms2,
							vertexShader: document.getElementById( 'vertexShader' ).textContent,
							fragmentShader: document.getElementById( 'fragmentShader'+x ).textContent
						} );	
					}		
					material.side=THREE.DoubleSide;
					// material.transparent=true;
					matList.push(material)		
				}
				return matList;
			}

			function updatePictureChroma(){
				tempData=context.getImageData(0,0,256,256).data;
				for(var x=0; x<tempData.length; x=x+3){
					if(globalController.PictureChroma<0){
						if( (tempData[x]+tempData[x+1]+tempData[x+2])/3 < Math.abs(globalController.PictureChroma)){
							tempData[x]=0;
							tempData[x+1]=0;
							tempData[x+2]=0;
						}
					}
					if(globalController.PictureChroma>0){
						if( (tempData[x]+tempData[x+1]+tempData[x+2])/3 > 255-globalController.PictureChroma){
							tempData[x]=0;
							tempData[x+1]=0;
							tempData[x+2]=0;
						}
					}
				}
				dataTex = new THREE.DataTexture(tempData, 256, 256);
				dataTex.needsUpdate = true; 
				changeMask(3);
			}
					
			function getVideo(action,camNum) {
				if(action == "init"){
					numOfCameras=0
					cameraIds=[]
					selectedCamera=0;
					videoElem='video'
					navigator.mediaDevices.enumerateDevices().then(function(deviceInfos){
					  for (var i = 0; i !== deviceInfos.length; ++i) {
						var deviceInfo = deviceInfos[i];
						if (deviceInfo.kind === 'videoinput') {
						  numOfCameras=numOfCameras + 1
						  cameraIds.push(deviceInfo.deviceId);
						}
					  }
					  gui.__folders.Utils.__controllers[gui.__folders.Utils.__controllers.length-1].__max=numOfCameras-1;
					  selectedCamera=camNum;
					  if (window.stream) {
						window.stream.getTracks().forEach(function(track) {
						  track.stop();
						});
					  }
					  console.log(cameraIds[selectedCamera])
					  var videoSource = cameraIds[selectedCamera];
					  var constraints = {video: {deviceId: videoSource ? {exact: videoSource} : undefined}};
					  navigator.mediaDevices.getUserMedia(constraints).then(function(stream){
						  window.stream = stream; 
						  document.getElementById(videoElem).srcObject = stream;
						  return navigator.mediaDevices.enumerateDevices();
					  }).catch(function(error){
						  console.log('navigator.getUserMedia error: ', error);
					  });
					  }).catch(function(error){
						console.log('navigator.getUserMedia error: ', error);
					  });
				}
				if(action == "select"){
					selectedCamera=camNum;
					if (window.stream) {
					  window.stream.getTracks().forEach(function(track) {
						track.stop();
					  });
					}
					console.log(cameraIds[selectedCamera])
					var videoSource = cameraIds[selectedCamera];
					var constraints = {video: {deviceId: videoSource ? {exact: videoSource} : undefined}};
					navigator.mediaDevices.getUserMedia(constraints).then(function(stream){
						window.stream = stream; 
						document.getElementById(videoElem).srcObject = stream;
						return navigator.mediaDevices.enumerateDevices();
					}).catch(function(error){
						console.log('navigator.getUserMedia error: ', error);
					});
				}
			}	

			function getDMXPatternData(patNum,ledStripPatternsArray){
				var patternData=[];
				var xmlhttp=new XMLHttpRequest();
				xmlhttp.open("GET", "php/read.php?fn=dmxPresets/pattern"+patNum+".txt", true);
				xmlhttp.send();
				xmlhttp.onload = function(e){
                    var patternDataString=xmlhttp.response;
					var patternDataStringArray=patternDataString.split('\n');
					for(var x=0; x<patternDataStringArray.length-1; x++){
						var temp=patternDataStringArray[x].split(',');
						patternData.push(temp);
					}
					ledStripPatternsArray.push(patternData);
					if(patNum<numberOfDMXPatterns){
						getDMXPatternData(patNum+1,ledStripPatternsArray);
					}else{
						console.log("loaded all led strip data");
					}
				}
			}
			
			function initScene() {
				// prevData=pixel8(video,0,0,width,height)
				imgTexture = new THREE.TextureLoader().load( 'masks/mask1.jpg' );
				imgTexture2 = new THREE.TextureLoader().load( 'masks/mask2.jpg' );
				dataTexture=[]	
				dataTexture = new THREE.DataTexture( materialArray, width, height, THREE.RGBAFormat );
				dataTexture.needsUpdate = true;
				uniforms1 = {
					"time": { value: 1.0 },
					"resolution": [width,height],
					"mousex": { value: 0.0 },
					"mousey": { value: 0.0 },
					"audioVolume": { value: 0.0 },
					"maskTexture": { value: imgTexture },
					"brightness": { value: globalController.BrightnessA }
				};
				uniforms2 = {
					"time": { value: 1.0 },
					"resolution": [width,height],
					"mousex": { value: 0.0 },
					"mousey": { value: 0.0 },
					"audioVolume": { value: 0.0 },
					"maskTexture": { value: imgTexture2 },
					"brightness": { value: globalController.BrightnessB }
				};
				// uniforms1[ "maskTexture" ].value.wrapS = uniforms1[ "maskTexture" ].value.wrapT = THREE.MirroredRepeatWrapping;
				materialsList=initShaderMaterial(uniforms1);
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				frustumSize = 1000;
				var aspect = window.innerWidth / window.innerHeight;
				camera = new THREE.OrthographicCamera( frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 0, 10000 );
				camera.position.z = -1000;
				controls = new THREE.TrackballControls( camera , container);
				controls.enabled=false;
				LIGHTING1=new THREE.AmbientLight( 0xffffff );
				LIGHTING2=new THREE.AmbientLight( 0xffffff ) 
				scene1 = new THREE.Scene();
				scene1.add( LIGHTING1 );
				scene2 = new THREE.Scene();
				scene2.add( LIGHTING2 );
				scene=scene1;
				renderer = new THREE.WebGLRenderer( { antialias: true , alpha:true} );
				renderer.setClearColor( 0x000000 , 1);
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.sortObjects = true;
				renderer.domElement.style.cursor = "none";
				container.appendChild( renderer.domElement );
				renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
				renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
				renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );
				renderer.domElement.addEventListener( 'touchmove', onDocumentTouchMove, false );
                renderer.domElement.addEventListener( 'touchstart', onDocumentTouchStart, false );
                renderer.domElement.addEventListener( 'touchend', onDocumentTouchEnd, false );
				window.addEventListener( 'resize', onWindowResize, false );
				tempElem=document.body.getElementsByClassName('ac')[0];
				tempElem.className="";
				tempElem.style.zIndex='10000000'
				tempElem.style.position='fixed'
				tempElem.style.right='0px';
			}
				
			function addControls(){
				globalController  = {
					selectedObject:0,
					mappingMode:0,
					ShaderA:1,
					ShaderB:2,
					MaskA:1,
					MaskB:2,
					PresetName:"GlobalPreset1",
					SendDMX:true,
					DMX_Rate: 50,
					DMX_Brightness:.5,
					DMX_Pattern:1,
					DMX_Pattern_Rate:.1,
					Universe:1,
					DMX_X1:0,
					DMX_Y1:175,
					DMX_X2:150,
					DMX_Y2:175,
					VolumeThreshold:.003,
					Camera_X:0.0,
					Camera_Y:0.0,
					BrightnessA:1.0,
					BrightnessB:1.0,
					SavedByController:false,
					PictureChroma:150,
				}
				objectController  = {
					 Visible:false,
					 ZValue:0,
					 Shader:1
				};
				var count=0; 
				for(var y=4; y>=0;y--){
					for(var x=0; x<5;x++){
						objectController["VerticeX"+count]=-200+100*x;
						objectController["VerticeY"+count]=-200+100*y;
						count=count+1;
					}
				}
				gui = new dat.GUI();
				gui.width=360;
				globalFolder=gui.addFolder( "Global" )
				globalFolder.open();
				globalFolder.add(globalController, "selectedObject", 0, 3, 1 ).onChange(function(){globalController.selectedObject=parseInt(globalController.selectedObject);updateControlsView();syncObjectsToJson();});
				globalFolder.add(globalController, "ShaderA", 1, 11, 1 ).onChange(function(){globalController.ShaderA=parseInt(globalController.ShaderA);loadShaderPreset(1);updateControlsValues();});				
				globalFolder.add(globalController, "ShaderB", 1, 11, 1 ).onChange(function(){globalController.ShaderB=parseInt(globalController.ShaderB);loadShaderPreset(2);updateControlsValues();});								
				globalFolder.add(globalController, "MaskA", 1, 3, 1 ).onChange(function(){globalController.MaskA=parseInt(globalController.MaskA); changeMask(1); updateControlsValues();});				
				globalFolder.add(globalController, "MaskB", 1, 3, 1 ).onChange(function(){globalController.MaskB=parseInt(globalController.MaskB); changeMask(2); updateControlsValues();});
				globalFolder.add( globalController, "BrightnessA", 0.0,1.0,.001 ).onChange(function(){updateControlsValues();});			
				globalFolder.add( globalController, "BrightnessB", 0.0,1.0,.001 ).onChange(function(){updateControlsValues();});	
				globalFolder.add( globalController, "VolumeThreshold", .0001,.1,.0001 ).onChange(function(){updateControlsValues();});	
				// globalFolder.add( globalController, "Camera_X", -1.0,1.0,.001 ).onChange(function(){camera.position.x=globalController.Camera_X*window.innerWidth/3; updateControlsValues();});
				// globalFolder.add( globalController, "Camera_Y", -1.0,1.0,.001 ).onChange(function(){camera.position.y=globalController.Camera_Y*window.innerHeight/3; updateControlsValues();});		
				controlsFolder=gui.addFolder( "ObjectControls" )
				controlsFolder.open();
				controlsFolder.add( objectController, "Visible", true ).onChange(function(){updateControlsValues();syncObjectsToJson();});	
				controlsFolder.add( objectController, "ZValue", -20, 20, 1 ).onChange(function(){updateControlsValues();syncObjectsToJson()});
				controlsFolder.add( objectController, "Shader", 1, 2, 1 ).onChange(function(){objectController.Shader=parseInt(objectController.Shader);updateControlsValues();syncObjectsToJson()});
				dmxFolder=gui.addFolder( "DMX" );
				dmxFolder.open();
				dmxFolder.add(globalController, "DMX_Pattern", 1,6,1 ).onChange(function(){globalController.DMX_Pattern=parseInt(globalController.DMX_Pattern);  updateControlsValues();});
				dmxFolder.add(globalController, "DMX_Brightness", 0.0, 1.0, .01 ).onChange(function(){updateControlsValues(); });
				dmxFolder.add(globalController, "DMX_Pattern_Rate", 0.00,4.0,.01 ).onChange(function(){updateControlsValues(); });
				dmxFolder.add( globalController, "DMX_X1", 1,255,1 ).onChange(function(){globalController.DMX_X1=parseInt(globalController.DMX_X1);updateControlsValues();});
				dmxFolder.add( globalController, "DMX_Y1", 1,255,1 ).onChange(function(){globalController.DMX_Y1=parseInt(globalController.DMX_Y1);updateControlsValues();});
				dmxFolder.add( globalController, "DMX_X2", 1,255,1 ).onChange(function(){globalController.DMX_X2=parseInt(globalController.DMX_X2);updateControlsValues();});
				dmxFolder.add( globalController, "DMX_Y2", 1,255,1 ).onChange(function(){globalController.DMX_Y2=parseInt(globalController.DMX_Y2);updateControlsValues();});
				utilsFolder=gui.addFolder( "Utils" )
				utilsFolder.open();
				// utilsFolder.add( globalController, "PictureChroma", -255,255, 1).onChange(function(){updatePictureChroma();});	
				utilsFolder.add({ 'Mask/Map Mode':function(){ if(isMaskMode==false){toggleMaskMode("mask");}else{toggleMaskMode("map") }; }},'Mask/Map Mode');
				utilsFolder.add({ 'Reset Mask':function(){ resetMaskHandles();}},'Reset Mask');
				utilsFolder.add({ 'Full Screen':function(){ requestFullScreen() }},'Full Screen');
				utilsFolder.add({ 'PresentationMode':function(){ for(var x=0;x<displayObjects[globalController.selectedObject].children.length;x++){ displayObjects[globalController.selectedObject].children[x].visible=false; } ; requestFullScreen(); gui.close();document.getElementsByClassName("close-button")[0].innerHTML=""; setTimeout(function(){ document.getElementsByClassName("close-button")[0].style.width=10; document.getElementsByClassName("close-button")[0].style.right=0;},1000);}},'PresentationMode');
				utilsFolder.add({ 'Save Preset':function(){ saveState() }},'Save Preset');
				utilsFolder.add({ 'Recall Preset':function(){ recallState() }},'Recall Preset');
				utilsFolder.add(globalController, 'PresetName').onChange(function(){});
				utilsFolder.add({ 'Shader Editor':function(){ window.location.replace("http://"+location.hostname+"/editors/shaderEditor.html"); }},'Shader Editor');
				utilsFolder.add({ 'Controller App':function(){ window.location.replace("http://"+location.hostname+"/controller/index.html"); }},'Controller App');
				utilsFolder.add({ 'DMX Editor':function(){ window.location.replace("http://"+location.hostname+"/editors/dmxEditor.html"); }},'DMX Editor');
				utilsFolder.add({ 'FlowMapper':function(){ window.location.replace("http://"+location.hostname+"/FlowMapper.html"); }},'FlowMapper');
				utilsFolder.add({ 'OrbitMapper':function(){ window.location.replace("http://"+location.hostname+"/OrbitMapper.html"); }},'OrbitMapper');
				miscFolder=gui.addFolder( "Remote Control" )
				miscFolder.open();
				miscFolder.add({ 'Slave Mode':function(){  initSlaveMode(); }},'Slave Mode');
				miscFolder.add({ 'Controller Mode':function(){ initControllerMode();  }},'Controller Mode');
				miscFolder.add({ 'Standalone':function(){ initStandaloneMode();  }},'Standalone');
			}

			function initSlaveMode(){
				if(slaveModeInterval==-1){
					console.log("starting slaveModeInterval");
					getControllerData(true);
					slaveModeInterval=setInterval(function(){getControllerData(false);getCurrentPresetNumber();},  110);
				}
			}

			function getControllerData(isFirstRun){
				var xmlhttp=new XMLHttpRequest();
				xmlhttp.open("GET", "php/read.php?fn=globalPresets/"+globalController.PresetName+".txt", true);
				xmlhttp.send();
				xmlhttp.onload = function(e){
					if(lastObjectVerticeData!=xmlhttp.response || isFirstRun || haveChangedLocalSettingsInControllerMode){

						globalState=JSON.parse(xmlhttp.response).global;
						if(globalState.SavedByController==true){

							var temp=JSON.parse(xmlhttp.response).storage;
							for(var x=0; x<4; x++){
								for(var y=0; y<25; y++){
									temp[x]["VerticeX"+y]=temp[x]["VerticeX"+y]*2;
									temp[x]["VerticeY"+y]=temp[x]["VerticeY"+y]*2;
									// temp[x]["VerticeX"+y]=temp[x]["VerticeX"+y]+window.innerWidth*.04;
									// temp[x]["VerticeY"+y]=temp[x]["VerticeY"+y]-window.innerHeight*.09;
								}						
							}
							statesArray=temp;

							var temp2=JSON.parse(xmlhttp.response).maskHandles;
							for(var x=0; x<numMaskHandles; x++){
								temp2[x].x=temp2[x].x*maskControllerScalingFactor;
								temp2[x].y=temp2[x].y*maskControllerScalingFactor;
							}
							maskHandleState=temp2;
							
						}else{
							statesArray=JSON.parse(xmlhttp.response).storage
						}

						updateControlsView();
						drawMaskCanvas();
						syncObjectsToJson(true);
						for(var x=0;x<displayObjects[globalController.selectedObject].children.length;x++){ displayObjects[globalController.selectedObject].children[x].visible=false; };
						uniforms1.mousey={ value: globalState.xyPadYA };
						uniforms2.mousey={ value: globalState.xyPadYB };
						uniforms1.mousex={ value: globalState.xyPadXA };
						uniforms2.mousex={ value: globalState.xyPadXB };
						lastObjectVerticeData=xmlhttp.response;
						haveChangedLocalSettingsInControllerMode=false;
						// console.log("responded to controller data");
					}
				}
			}

			function checkForForceInitControllerMode(){
				var xmlhttp=new XMLHttpRequest();
				xmlhttp.open("GET", "php/read.php?fn=globalPresets/forceInitControllerMode.txt", true);
				xmlhttp.send();
				xmlhttp.onload = function(e){
					if(xmlhttp.response=="true"){
						console.log("Controller Mode Remotely Activated");
						initSlaveMode();
						resetForceInitControllerMode();

					}
					setTimeout(function(){
						checkForForceInitControllerMode();
					}, 2000);
				}
			}

			function resetForceInitControllerMode(){
				var requestBody="false"
				var xmlhttp=new XMLHttpRequest();
				xmlhttp.open("POST", "php/write.php?fn=globalPresets/forceInitControllerMode.txt", true);
				xmlhttp.send(requestBody);
				xmlhttp.onload = function(e){
					console.log("Wrote 'false' to forceInitControllerMode");
				}
			}
			
			function getCurrentPresetNumber(){
				var xmlhttp=new XMLHttpRequest();
				xmlhttp.open("GET", "php/read.php?fn=globalPresets/currentPreset.txt", true);
				xmlhttp.send();
				xmlhttp.onload = function(e){
					globalState.PresetName="GlobalPreset"+parseInt(xmlhttp.response);
					globalController.PresetName="GlobalPreset"+parseInt(xmlhttp.response);
					gui.__folders.Utils.__controllers.filter(obj => { return obj.property == "PresetName"})[0].updateDisplay();
				}
			}

			function initControllerMode(){
				if(controllerModeInterval==-1){
					console.log("starting controllerModeInterval");
					controllerModeInterval=setInterval(function(){saveState();},  400);
				}
			}

			function initStandaloneMode(){
				if(slaveModeInterval!=-1){
					console.log("stopping slaveModeInterval");
					clearInterval(slaveModeInterval);
					slaveModeInterval=-1;
				}
				if(controllerModeInterval!=-1){
					console.log("stopping controllerModeInterval");
					clearInterval(controllerModeInterval);
					slaveModeInterval=-1;
				}
			}
									
			function changeMask(changedMask){
				if(changedMask==1){
					if(parseInt(globalController.MaskA)!=lastMaskAValue){
						if(parseInt(globalController.MaskA)<numberOfMasks+1){
							uniforms1.maskTexture={ value: new THREE.TextureLoader().load( 'masks/mask'+parseInt(globalController.MaskA)+'.jpg' ) };
							lastMaskAValue=parseInt(globalController.MaskA);
						}else{
							uniforms1.maskTexture.value=dataTex;
							lastMaskAValue=parseInt(globalController.MaskA);							
						}
					}
				}
				if(changedMask==2){
					if(parseInt(globalController.MaskB)!=lastMaskBValue){
						if(parseInt(globalController.MaskB)<numberOfMasks+1){
							uniforms2.maskTexture={ value: new THREE.TextureLoader().load( 'masks/mask'+parseInt(globalController.MaskB)+'.jpg' ) };
							lastMaskBValue=parseInt(globalController.MaskB);
						}else{
							uniforms2.maskTexture=dataTex;
							lastMaskBValue=parseInt(globalController.MaskB);							
						}
					}
				}
				if(changedMask==3){
					if(parseInt(globalController.MaskA)==numberOfMasks+1){
						uniforms1.maskTexture.value=dataTex;
						lastMaskAValue=parseInt(globalController.MaskA);							
					}
					if(parseInt(globalController.MaskB)==numberOfMasks+1){
						uniforms2.maskTexture.value=dataTex;
						lastMaskBValue=parseInt(globalController.MaskB);							
					}
				}
			}
			
			function loadShaderPreset(shaderNum){
				if(shaderNum==1){
					var shaverVal=parseInt(globalController.ShaderA);
				}else{
					var shaverVal=parseInt(globalController.ShaderB);
				}
				var xmlhttp=new XMLHttpRequest();
				xmlhttp.open("GET", "php/read.php?fn=fragmentShaders/shader"+parseInt(shaverVal)+".txt", true);
				xmlhttp.send();
				xmlhttp.onload = function(e){
					// console.log(xmlhttp.response)
					document.getElementById( 'fragmentShader'+parseInt(shaderNum)).textContent=xmlhttp.response;
					materialsList=initShaderMaterial(uniforms1);
					for(var i=0;i<displayObjects.length;i++){
						if(statesArray[i].Visible==true){
							displayObjects[i].material=materialsList[statesArray[i].Shader-1]
						}
					}
					// syncObjectsToJson();
				}
			}
			
			function updateControlsView(){
				for (var i in gui.__folders.ObjectControls.__controllers) {
				  	objectController[gui.__folders.ObjectControls.__controllers[i].property]=statesArray[parseInt(globalController.selectedObject)][gui.__folders.ObjectControls.__controllers[i].property];
					gui.__folders.ObjectControls.__controllers[i].updateDisplay();
				}
				for (var i in gui.__folders.Global.__controllers) {
					if(i!=0){
						globalController[gui.__folders.Global.__controllers[i].property]=globalState[gui.__folders.Global.__controllers[i].property];
						gui.__folders.Global.__controllers[i].updateDisplay();
					}
				}
				for (var i in gui.__folders.DMX.__controllers) {
					globalController[gui.__folders.DMX.__controllers[i].property]=globalState[gui.__folders.DMX.__controllers[i].property];
					gui.__folders.DMX.__controllers[i].updateDisplay();
				}
			}
			
			function updateControlsValues(){  
				haveChangedLocalSettingsInControllerMode=true;
				for (var i in gui.__folders.ObjectControls.__controllers) {
				  statesArray[parseInt(globalController.selectedObject)][gui.__folders.ObjectControls.__controllers[i].property]=objectController[gui.__folders.ObjectControls.__controllers[i].property];
				}
				for (var i in gui.__folders.Global.__controllers) {
					globalState[gui.__folders.Global.__controllers[i].property]=globalController[gui.__folders.Global.__controllers[i].property];
				}
				for (var i in gui.__folders.DMX.__controllers) {
					globalState[gui.__folders.DMX.__controllers[i].property]=globalController[gui.__folders.DMX.__controllers[i].property];
				}
			}
			
			function syncObjectsToJson(includGlobal){
				haveChangedLocalSettingsInControllerMode=true;
				for(var x=0;x<displayObjects.length;x++){
					displayObjects[x].setState(statesArray[x])
					displayObjects[x].hideChildren();
				}
				displayObjects[globalController.selectedObject].showChildren();

				//--------------------------
				if(includGlobal){
					changeMask(1);
					changeMask(2);
					loadShaderPreset(1);
					loadShaderPreset(2);
					camera.position.x=globalController.Camera_X*window.innerWidth/3;
					camera.position.y=globalController.Camera_Y*window.innerHeight/3;

				}

				for(var x=0;x<maskHandleState.length;x++){
					maskHandleObjects[x].position.x=maskHandleState[x].x;
					maskHandleObjects[x].position.y=maskHandleState[x].y*-1;
					maskHandleLinesGeometry.attributes.position.array[x*3]=maskHandleState[x].x;
					maskHandleLinesGeometry.attributes.position.array[(x*3)+1]=maskHandleState[x].y*-1;
				}
				maskHandleLinesGeometry.attributes.position.array[(maskHandleState.length)*3]=maskHandleState[0].x;
				maskHandleLinesGeometry.attributes.position.array[((maskHandleState.length)*3)+1]=maskHandleState[0].y*-1;
				maskHandleLinesGeometry.attributes.position.needsUpdate = true; 
			}
			
			function addObject(){
			  function createGeometry(u,v){
					nsControlPoints = [
						 [
							 new THREE.Vector4 ( -200, -200, 0, 1 ),
							 new THREE.Vector4 ( -200, -100, 0, 1 ),
							 new THREE.Vector4 ( -200, 100, 0, 1 ),
							 new THREE.Vector4 ( -200, 200, 0, 1 )
						 ],
						 [
							 new THREE.Vector4 ( 0, -200, 0, 1 ),
							 new THREE.Vector4 ( 0, -100, 0, 1 ),
							 new THREE.Vector4 ( 0, 100, 0, 1 ),
							 new THREE.Vector4 ( 0, 200, 0, 1 )
						 ],
						 [
							 new THREE.Vector4 ( 200, -200, 0, 1 ),
							 new THREE.Vector4 ( 200, -100, 0, 1 ),
							 new THREE.Vector4 ( 200, 100, 0, 1 ),
							 new THREE.Vector4 ( 200, 200, 0, 1 )
						 ]
					 ];
					 degree1 = 2
					 degree2 = 3;
					 knots1 = [0, 0, 0, 1, 1, 1];
					 knots2 = [0, 0, 0, 0, 1, 1, 1, 1];
					 nurbsSurface = new THREE.NURBSSurface(degree1, degree2, knots1, knots2, nsControlPoints);
					 return nurbsSurface.getPoint(u, v);		
			  }
			  function createObject(){
				var geometry = new THREE.ParametricGeometry( createGeometry, 4, 4 );			  
				//var geometry=new THREE.BoxGeometry( 10, 10, 10 );
				var object = new THREE.Mesh( geometry, materialsList[0]);				
				return object;
			  }
			  var object = createObject();
			  object.showChildren=function(){
			        if (globalController.mappingMode>.5) {
						for(var x=0; x<object.children.length ;x++){
								object.children[x].visible=true;							
						}
					}else{
						for(var x=0; x<object.children.length ;x++){
							if (object.children[x].isCorner==true) {
								object.children[x].visible=true;
								object.updatecorners;
							}
						}					
					}
			  }
			  object.hideChildren=function(){
				for(var x=object.children.length-1;x>=0 ;x--){
						object.children[x].visible=false;			
				}
			  }
			  object.drawV=function(){
				for(var x=0; x<object.geometry.vertices.length ; x++ ){
					//var  geo = new THREE.BoxGeometry( 35, 35, 0 );
					//var mat = new THREE.PointsMaterial( { size: 300, vertexColors: THREE.VertexColors , color: 0xffffff } );
					//var mesh1 = new THREE.Mesh( geo, mat );
					mesh1 = new THREE.Mesh( new THREE.CircleGeometry(20, 20, 0, Math.PI * 2 ), new THREE.MeshPhongMaterial({side: THREE.DoubleSide, color:0xffffff}))
					mesh1.name="vertice"+x;
					mesh1.isCorner=false;
					if (x == 0 || x == 4 || x == 24 || x == 20) {
						mesh1.isCorner=true;
					}
					mesh1.vertNum=x;
					mesh1.position.x=object.geometry.vertices[x].x;
					mesh1.position.y=object.geometry.vertices[x].y;
					mesh1.position.z=-5;
					object.add(mesh1)
					objects.push(mesh1)
				}
			  }
			  object.setState=function(savedJSON){
				object.visible=savedJSON.Visible;
				object.position.z= savedJSON.ZValue
				object.material=materialsList[parseInt(savedJSON.Shader-1)]
				for(var x=0;x<object.geometry.vertices.length;x++){
					object.geometry.vertices[x].x=savedJSON["VerticeX"+x]
					object.geometry.vertices[x].y=savedJSON["VerticeY"+x]
					object.children[x].position.x=savedJSON["VerticeX"+x]
					object.children[x].position.y=savedJSON["VerticeY"+x]
				}
				object.geometry.verticesNeedUpdate = true;
			  }	  
			  object.updateCorners=function(){
					var cornerNum=[];
					cornerNum[0]=0;
					cornerNum[1]=Math.sqrt(object.geometry.vertices.length)-1
					cornerNum[2]=object.geometry.vertices.length-1-(Math.sqrt(object.geometry.vertices.length)-1)
					cornerNum[3]=object.geometry.vertices.length-1
					var x1 = object.geometry.vertices[cornerNum[0]].x
					var y1 = object.geometry.vertices[cornerNum[0]].y
					var x2 = object.geometry.vertices[cornerNum[1]].x
					var y2 = object.geometry.vertices[cornerNum[1]].y
					var x3 = object.geometry.vertices[cornerNum[2]].x
					var y3 = object.geometry.vertices[cornerNum[2]].y
					var x4 = object.geometry.vertices[cornerNum[3]].x
					var y4 = object.geometry.vertices[cornerNum[3]].y
					var xDiff1=(x2-x1)/(Math.sqrt(object.geometry.vertices.length)-1)
					var yDiff1=(y2-y1)/(Math.sqrt(object.geometry.vertices.length)-1)
					for(var x=0; x<Math.sqrt(object.geometry.vertices.length);x++){
						 object.geometry.vertices[x].x=+object.geometry.vertices[0].x+xDiff1*x;
						 object.geometry.vertices[x].y=object.geometry.vertices[0].y+yDiff1*x;
					}
					xDiff1=(x3-x1)/(Math.sqrt(object.geometry.vertices.length)-1)
					yDiff1=(y3-y1)/(Math.sqrt(object.geometry.vertices.length)-1)
					for(var x=0; x<Math.sqrt(object.geometry.vertices.length);x++){
						 object.geometry.vertices[(Math.sqrt(object.geometry.vertices.length))*x].x=+object.geometry.vertices[0].x+xDiff1*x;
						 object.geometry.vertices[(Math.sqrt(object.geometry.vertices.length))*x].y=object.geometry.vertices[0].y+yDiff1*x;
					}
					xDiff1=(x4-x3)/(Math.sqrt(object.geometry.vertices.length)-1)
					yDiff1=(y4-y3)/(Math.sqrt(object.geometry.vertices.length)-1)
					for(var x=object.geometry.vertices.length-1; x>object.geometry.vertices.length-Math.sqrt(object.geometry.vertices.length);x--){
						 object.geometry.vertices[x].x=object.geometry.vertices[object.geometry.vertices.length-1].x+xDiff1*(x-(object.geometry.vertices.length-1));
						 object.geometry.vertices[x].y=object.geometry.vertices[object.geometry.vertices.length-1].y+yDiff1*(x-(object.geometry.vertices.length-1));
					}
					xDiff1=(x4-x2)/(Math.sqrt(object.geometry.vertices.length)-1)
					yDiff1=(y4-y2)/(Math.sqrt(object.geometry.vertices.length)-1)
					for(var x=0; x<Math.sqrt(object.geometry.vertices.length);x++){
						 object.geometry.vertices[(Math.sqrt(object.geometry.vertices.length))*x+Math.sqrt(object.geometry.vertices.length)-1].x=object.geometry.vertices[(Math.sqrt(object.geometry.vertices.length)-1)].x+xDiff1*(x);
						 object.geometry.vertices[(Math.sqrt(object.geometry.vertices.length))*x+Math.sqrt(object.geometry.vertices.length)-1].y=object.geometry.vertices[(Math.sqrt(object.geometry.vertices.length)-1)].y+yDiff1*(x);
					}
					var sqrt=(Math.sqrt(object.geometry.vertices.length))
					var numOfMiddleRows=(Math.sqrt(object.geometry.vertices.length)-2)
					for(var rowNum = 1; rowNum < (Math.sqrt(object.geometry.vertices.length)-1) ; rowNum ++){
						 var x1 = object.geometry.vertices[rowNum*sqrt].x
						 var y1 = object.geometry.vertices[rowNum*sqrt].y
						 var x2 = object.geometry.vertices[rowNum*sqrt+(sqrt-1)].x
						 var y2 = object.geometry.vertices[rowNum*sqrt+(sqrt-1)].y
						 xDiff1=(x2-x1)/(Math.sqrt(object.geometry.vertices.length)-1)
						 yDiff1=(y2-y1)/(Math.sqrt(object.geometry.vertices.length)-1)
						 for(var x=0; x<(Math.sqrt(object.geometry.vertices.length)-1) ; x++ ){
							  object.geometry.vertices[rowNum*sqrt+x].x= x1+xDiff1*x;
							  object.geometry.vertices[rowNum*sqrt+x].y= y1+yDiff1*x;
						 }
					}
					
					object.geometry.verticesNeedUpdate = true;
					//object.drawV()
					for(var x=0;x<object.geometry.vertices.length;x++){
						objectController["VerticeX"+x]=object.geometry.vertices[x].x;
						objectController["VerticeY"+x]=object.geometry.vertices[x].y;
					}
					for(var x=0;x<object.children.length;x++){
						if(object.children[x].name.indexOf("vertice"!=0)){
							object.children[x].position.x=object.geometry.vertices[x].x;
							object.children[x].position.y=object.geometry.vertices[x].y;
							statesArray[globalController.selectedObject]["VerticeX"+x]=object.geometry.vertices[x].x;
							statesArray[globalController.selectedObject]["VerticeY"+x]=object.geometry.vertices[x].y;
						}		
					}
					updateControlsValues();
					//updateControlsView();
			  }
			  object.drawV();
			  object.visible=false;
			  scene.add(object);
			  displayObjects.push(object);
			}
									
			function onWindowResize() {
				var aspect = window.innerWidth / window.innerHeight;
				camera.left   = - frustumSize * aspect / 2;
				camera.right  =   frustumSize * aspect / 2;
				camera.top    =   frustumSize / 2;
				camera.bottom = - frustumSize / 2;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			
			function onDocumentTouchMove(event){
				if (SELECTED) {
					if (SELECTED.isCorner==true && globalController.mappingMode<.5) {
						console.log(SELECTED)
						SELECTED.parent.updateCorners();
					}
				}
                mouse.x = ( event.touches[0].clientX / window.innerWidth ) * 2.0 - 1.0;
                mouse.y = - ( event.touches[0].clientY / window.innerHeight ) * 2.0 + 1.0;

				uniforms1.mousey={ value: mouse.y };
				uniforms2.mousey={ value: mouse.y };
				uniforms1.mousex={ value: mouse.x };
				uniforms2.mousex={ value: mouse.x };
				raycaster.setFromCamera( mouse, camera );
				if ( SELECTED ) {
					
					if ( raycaster.ray.intersectPlane( plane, intersection ) ) {
						if (SELECTED.name.indexOf('vertice') != -1 && SELECTED.name.indexOf('corner') == -1 && isMaskMode==false) {
						    console.log(SELECTED.name)
							SELECTED.position.copy(intersection.sub( offset ));
							SELECTED.parent.geometry.vertices[SELECTED.name.substring(SELECTED.name.indexOf("ce")+2,SELECTED.name.length)].x=SELECTED.position.x;
							SELECTED.parent.geometry.vertices[SELECTED.name.substring(SELECTED.name.indexOf("ce")+2,SELECTED.name.length)].y=SELECTED.position.y;
							SELECTED.parent.geometry.verticesNeedUpdate = true;
							statesArray[parseInt(globalController.selectedObject)]["VerticeX"+SELECTED.vertNum]=SELECTED.position.x;						
							statesArray[parseInt(globalController.selectedObject)]["VerticeY"+SELECTED.vertNum]=SELECTED.position.y;			
						}
						if(SELECTED.name.indexOf('maskHandle') != -1 && isMaskMode==true){
							console.log(SELECTED.name);
							SELECTED.position.copy(intersection.sub( offset ));
							maskHandleState[SELECTED.num].x=SELECTED.position.x;
							maskHandleState[SELECTED.num].y=SELECTED.position.y*-1;
							drawMaskCanvas();
							syncObjectsToJson();
						}
					}
					return;
				}
				var intersects = raycaster.intersectObjects( objects);
				if ( intersects.length > 0 ) {
					if ( INTERSECTED != intersects[ 0 ].object ) {
						INTERSECTED = intersects[ 0 ].object;
						plane.setFromNormalAndCoplanarPoint(
							camera.getWorldDirection( plane.normal ),
							INTERSECTED.position );
					}
					container.style.cursor = 'pointer';
				} else {
					INTERSECTED = null;
					container.style.cursor = 'auto';
				}
			}

			function onDocumentTouchStart(event){
				mouse.x = ( event.touches[0].clientX / window.innerWidth ) * 2.0 - 1.0;
                mouse.y = - ( event.touches[0].clientY / window.innerHeight ) * 2.0 + 1.0;
				requestFullScreen();
                raycaster.setFromCamera( mouse, camera );
				intersects = raycaster.intersectObjects( objects);
				if ( intersects.length > 0 ) {
					SELECTED = intersects[ 0 ].object;
					if ( raycaster.ray.intersectPlane( plane, intersection ) ) {
						offset.copy( intersection ).sub( SELECTED.position );
					}
					container.style.cursor = 'move';
				}
				if (SELECTED) {
					if (SELECTED.isCorner==true && globalController.mappingMode<.5 && isMaskMode==false) {
						// console.log(SELECTED)
						SELECTED.parent.updateCorners();

						var listOfCornerVertices=[4,0,20,24];
						selectedVertice=listOfCornerVertices.indexOf(SELECTED.vertNum);
						// console.log("Selected Vertice:"+selectedVertice);
						highlightSelectedVertice();
					}
					if(SELECTED.name.indexOf('maskHandle') != -1 && isMaskMode==true){
						selectedMaskHandle=SELECTED.num;
						highlightSelectedMaskHandle();
					}
				}
			}

            function onDocumentTouchEnd(event){
				SELECTED = null;
				//event.preventDefault();
				if (SELECTED) {
					if (SELECTED.isCorner==true && globalController.mappingMode<.5) {
						SELECTED.parent.updateCorners();
					}
				}
				
				container.style.cursor = 'auto';
			}

			function onDocumentMouseMove( event ) {

				renderer.domElement.style.cursor = "default";
				mouseLastMovedTime=new Date().getTime();

				if (SELECTED) {
					if (SELECTED.isCorner==true && globalController.mappingMode<.5) {
						console.log(SELECTED)
						SELECTED.parent.updateCorners();
					}
				}
				mouse.x = ( event.clientX / window.innerWidth ) * 2.0 - 1.0;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2.0 + 1.0;
				// console.log(event.clientX / window.innerWidth+"  "+event.clientY / window.innerHeight)
				if(slaveModeInterval==-1){
					uniforms1.mousey={ value: event.clientY / window.innerHeight };
					uniforms2.mousey={ value: event.clientY / window.innerHeight };
					uniforms1.mousex={ value: event.clientX / window.innerWidth };
					uniforms2.mousex={ value: event.clientX / window.innerWidth };
				}
				raycaster.setFromCamera( mouse, camera );
				if ( SELECTED ) {
					
					if ( raycaster.ray.intersectPlane( plane, intersection ) ) {
						if (SELECTED.name.indexOf('vertice') != -1 && SELECTED.name.indexOf('corner') == -1 && isMaskMode==false) {
						    console.log(SELECTED.name)
							SELECTED.position.copy(intersection.sub( offset ));
							SELECTED.parent.geometry.vertices[SELECTED.name.substring(SELECTED.name.indexOf("ce")+2,SELECTED.name.length)].x=SELECTED.position.x;
							SELECTED.parent.geometry.vertices[SELECTED.name.substring(SELECTED.name.indexOf("ce")+2,SELECTED.name.length)].y=SELECTED.position.y;
							SELECTED.parent.geometry.verticesNeedUpdate = true;
							statesArray[parseInt(globalController.selectedObject)]["VerticeX"+SELECTED.vertNum]=SELECTED.position.x;						
							statesArray[parseInt(globalController.selectedObject)]["VerticeY"+SELECTED.vertNum]=SELECTED.position.y;			
						}
						if(SELECTED.name.indexOf('maskHandle') != -1 && isMaskMode==true){
							console.log(SELECTED.name);
							SELECTED.position.copy(intersection.sub( offset ));
							maskHandleState[SELECTED.num].x=SELECTED.position.x;
							maskHandleState[SELECTED.num].y=SELECTED.position.y*-1;
							drawMaskCanvas();
							syncObjectsToJson();
						}
					}
					return;
				}
				var intersects = raycaster.intersectObjects( objects);
				if ( intersects.length > 0 ) {
					if ( INTERSECTED != intersects[ 0 ].object ) {
						INTERSECTED = intersects[ 0 ].object;
						plane.setFromNormalAndCoplanarPoint(
							camera.getWorldDirection( plane.normal ),
							INTERSECTED.position );
					}
					container.style.cursor = 'pointer';
				} else {
					INTERSECTED = null;
					container.style.cursor = 'auto';
				}
			}

			function drawMaskCanvas(){
				context=document.getElementById('maskCanvas').getContext("2d");
				context.clearRect(0,0,innerWidth,innerHeight);
				context.fillStyle = '#f00';
				context.beginPath();
				var scaleFactor=3;
				var offsetY=130;
				var offsetX=50;
				context.moveTo(maskHandleState[0].x/scaleFactor+offsetX, maskHandleState[0].y/scaleFactor+offsetY);
				for(var x=1;x<maskHandleState.length;x++){
					context.lineTo(maskHandleState[x].x/scaleFactor+offsetX,maskHandleState[x].y/scaleFactor+offsetY);
				}
				context.lineTo(maskHandleState[0].x/scaleFactor+offsetX,maskHandleState[0].y/scaleFactor+offsetY);
				context.closePath();
				context.fill();

				tempData=context.getImageData(0,0,256,256).data;
				dataTex = new THREE.DataTexture(tempData, 256, 256);
				dataTex.needsUpdate = true;
				changeMask(3);
			}
			
			function onDocumentMouseDown( event ) {
					raycaster.setFromCamera( mouse, camera );
					intersects = raycaster.intersectObjects( objects);
					if ( intersects.length > 0 ) {
						SELECTED = intersects[ 0 ].object;
						if ( raycaster.ray.intersectPlane( plane, intersection ) ) {
							offset.copy( intersection ).sub( SELECTED.position );
						}
						container.style.cursor = 'move';
					}
					if (SELECTED) {
						if (SELECTED.isCorner==true && globalController.mappingMode<.5 && isMaskMode==false) {
							// console.log(SELECTED)
							SELECTED.parent.updateCorners();

							var listOfCornerVertices=[4,0,20,24];
							selectedVertice=listOfCornerVertices.indexOf(SELECTED.vertNum);
							// console.log("Selected Vertice:"+selectedVertice);
							highlightSelectedVertice();
						}
						if(SELECTED.name.indexOf('maskHandle') != -1 && isMaskMode==true){
							selectedMaskHandle=SELECTED.num;
							highlightSelectedMaskHandle();
						}
					}
			}
			
			function onDocumentMouseUp( event ) {
				//event.preventDefault();
				if (SELECTED) {
					if (SELECTED.isCorner==true && globalController.mappingMode<.5) {
						SELECTED.parent.updateCorners();
					}
				}
				SELECTED = null;
				container.style.cursor = 'auto';
			}
				
			function animate() {
			    // if(painterController.ColorMix != 0){
				// 	colorCounter=colorCounter+painterController.ColorRate
				// 	if(colorCounter > 1){
				// 		colorCounter=0;
				// 		clr.change();
				// 	}
			    // }
				requestAnimationFrame( animate );
				render();
			}
			
			function render() {
				uniforms1[ "time" ].value += .01 * 5;
				uniforms2[ "time" ].value += .01 * 5;
				uniforms1[ "brightness" ].value=globalController.BrightnessA;
				uniforms2[ "brightness" ].value=globalController.BrightnessB;
				for(var x=0;x<displayObjects.length;x++){
					displayObjects[x].material.transparent=true
					displayObjects[x].material.needsUpdate=true
				}
				renderer.render( scene, camera );
			}
			
			function requestFullScreen() {
				// Supports most browsers and their versions.
				var element = document.body; // Make the body go full screen.
				var requestMethod = element.requestFullScreen || element.webkitRequestFullScreen || element.mozRequestFullScreen || element.msRequestFullScreen;
			
				if (requestMethod) { // Native full screen.
					requestMethod.call(element);
				} else if (typeof window.ActiveXObject !== "undefined") { // Older IE.
					var wscript = new ActiveXObject("WScript.Shell");
					if (wscript !== null) {
						wscript.SendKeys("{F11}");
					}
				}
			}
		
			function saveState(){
				globalState.SavedByController=false;
				var requestBody=JSON.stringify({"storage" : statesArray, "global": globalState, "maskHandles": maskHandleState})
				var xmlhttp=new XMLHttpRequest();
				xmlhttp.open("POST", "php/write.php?fn=globalPresets/"+globalController.PresetName+".txt", true);
				xmlhttp.send(requestBody);
				xmlhttp.onload = function(e){console.log(xmlhttp.response.status)}
			}
			
			function recallState(){
				var xmlhttp=new XMLHttpRequest();
				xmlhttp.open("GET", "php/read.php?fn=globalPresets/"+globalController.PresetName+".txt", true);
				xmlhttp.send();
				xmlhttp.onload = function(e){

					globalState=JSON.parse(xmlhttp.response).global;
					maskHandleState=JSON.parse(xmlhttp.response).maskHandles;
					if(globalState.SavedByController==true){

						var temp=JSON.parse(xmlhttp.response).storage;
						for(var x=0; x<4; x++){
							for(var y=0; y<25; y++){
								temp[x]["VerticeX"+y]=temp[x]["VerticeX"+y]*2;
								temp[x]["VerticeY"+y]=temp[x]["VerticeY"+y]*2;
								// temp[x]["VerticeX"+y]=temp[x]["VerticeX"+y]+window.innerWidth*.04;
								// temp[x]["VerticeY"+y]=temp[x]["VerticeY"+y]-window.innerHeight*.09;
							}						
						}
						statesArray=temp;

						var temp2=JSON.parse(xmlhttp.response).maskHandles;
						for(var x=0; x<numMaskHandles; x++){
							temp2[x].x=temp2[x].x*maskControllerScalingFactor;
							temp2[x].y=temp2[x].y*maskControllerScalingFactor;
						}
						maskHandleState=temp2;

					}else{
						statesArray=JSON.parse(xmlhttp.response).storage
					}

					updateControlsView();
					syncObjectsToJson(true);
					drawMaskCanvas();
					for(var x=0;x<displayObjects[globalController.selectedObject].children.length;x++){ displayObjects[globalController.selectedObject].children[x].visible=false; };
				}
			}	
			
			function keyHandler(event){
				if(event.key=="<"){
					if(globalController.selectedObject>0){
						globalController.selectedObject=globalController.selectedObject-1;
						updateControlsView();
						gui.__folders.Global.__controllers[0].updateDisplay();
						syncObjectsToJson();
					}else{
						globalController.selectedObject=3;
						updateControlsView();
						gui.__folders.Global.__controllers[0].updateDisplay();
						syncObjectsToJson();
					}
				}
				if(event.key==">"){
					if(globalController.selectedObject<3){
						globalController.selectedObject=globalController.selectedObject+1;
						updateControlsView();
						gui.__folders.Global.__controllers[0].updateDisplay();
						syncObjectsToJson();
					}else{
						globalController.selectedObject=0;
						updateControlsView();
						gui.__folders.Global.__controllers[0].updateDisplay();
						syncObjectsToJson();
					}
				}
				if(event.key=="?"){
					for(var x=0;x<displayObjects[globalController.selectedObject].children.length;x++){ 
						displayObjects[globalController.selectedObject].children[x].visible=false; 
					};
				}
				if(event.key=="C"){
					gui.close();
					document.getElementsByClassName("close-button")[0].innerHTML=""; 
					setTimeout(function(){ 
						document.getElementsByClassName("close-button")[0].style.width=10; 
						document.getElementsByClassName("close-button")[0].style.right=0;},1000);
				}
				if(event.key=="c"){
					gui.open();
				}
				if(event.key=="a"){
					if(isMaskMode==false){
						var listOfCornerVertices=[4,0,20,24];
						statesArray[globalController.selectedObject]["VerticeX"+listOfCornerVertices[selectedVertice]]=statesArray[globalController.selectedObject]["VerticeX"+listOfCornerVertices[selectedVertice]]+1;
						updateControlsView();
						syncObjectsToJson();
						displayObjects[globalController.selectedObject].updateCorners();
					}
					if(isMaskMode==true){
						maskHandleState[selectedMaskHandle].x=maskHandleState[selectedMaskHandle].x+1;
						syncObjectsToJson();
						drawMaskCanvas();
					}
				}
				if(event.key=="s"){
					if(isMaskMode==false){
						var listOfCornerVertices=[4,0,20,24];
						statesArray[globalController.selectedObject]["VerticeY"+listOfCornerVertices[selectedVertice]]=statesArray[globalController.selectedObject]["VerticeY"+listOfCornerVertices[selectedVertice]]-1;
						updateControlsView();
						syncObjectsToJson();
						displayObjects[globalController.selectedObject].updateCorners();
					}
					if(isMaskMode==true){
						maskHandleState[selectedMaskHandle].y=maskHandleState[selectedMaskHandle].y+1;
						syncObjectsToJson();
						drawMaskCanvas();
					}
				}
				if(event.key=="d"){
					if(isMaskMode==false){
						var listOfCornerVertices=[4,0,20,24];
						statesArray[globalController.selectedObject]["VerticeX"+listOfCornerVertices[selectedVertice]]=statesArray[globalController.selectedObject]["VerticeX"+listOfCornerVertices[selectedVertice]]-1;
						updateControlsView();
						syncObjectsToJson();
						displayObjects[globalController.selectedObject].updateCorners();
					}
					if(isMaskMode==true){
						maskHandleState[selectedMaskHandle].x=maskHandleState[selectedMaskHandle].x-1;
						syncObjectsToJson();
						drawMaskCanvas();
					}
				}
				if(event.key=="w"){
					if(isMaskMode==false){
						var listOfCornerVertices=[4,0,20,24];
						statesArray[globalController.selectedObject]["VerticeY"+listOfCornerVertices[selectedVertice]]=statesArray[globalController.selectedObject]["VerticeY"+listOfCornerVertices[selectedVertice]]+1;
						updateControlsView();
						syncObjectsToJson();
						displayObjects[globalController.selectedObject].updateCorners();
					}
					if(isMaskMode==true){
						maskHandleState[selectedMaskHandle].y=maskHandleState[selectedMaskHandle].y-1;
						syncObjectsToJson();
						drawMaskCanvas();
					}
				}
				if(event.key=="A"){
					if(isMaskMode==false){
						var listOfCornerVertices=[4,0,20,24];
						statesArray[globalController.selectedObject]["VerticeX"+listOfCornerVertices[selectedVertice]]=statesArray[globalController.selectedObject]["VerticeX"+listOfCornerVertices[selectedVertice]]+40;
						updateControlsView();
						syncObjectsToJson();
						displayObjects[globalController.selectedObject].updateCorners();
					}
					if(isMaskMode==true){
						maskHandleState[selectedMaskHandle].x=maskHandleState[selectedMaskHandle].x+20;
						syncObjectsToJson();
						drawMaskCanvas();
					}
				}
				if(event.key=="S"){
					if(isMaskMode==false){
						var listOfCornerVertices=[4,0,20,24];
						statesArray[globalController.selectedObject]["VerticeY"+listOfCornerVertices[selectedVertice]]=statesArray[globalController.selectedObject]["VerticeY"+listOfCornerVertices[selectedVertice]]-40;
						updateControlsView();
						syncObjectsToJson();
						displayObjects[globalController.selectedObject].updateCorners();
					}
					if(isMaskMode==true){
						maskHandleState[selectedMaskHandle].y=maskHandleState[selectedMaskHandle].y+20;
						syncObjectsToJson();
						drawMaskCanvas();
					}
				}
				if(event.key=="D"){
					if(isMaskMode==false){
						var listOfCornerVertices=[4,0,20,24];
						statesArray[globalController.selectedObject]["VerticeX"+listOfCornerVertices[selectedVertice]]=statesArray[globalController.selectedObject]["VerticeX"+listOfCornerVertices[selectedVertice]]-40;
						updateControlsView();
						syncObjectsToJson();
						displayObjects[globalController.selectedObject].updateCorners();
					}
					if(isMaskMode==true){
						maskHandleState[selectedMaskHandle].x=maskHandleState[selectedMaskHandle].x-20;
						syncObjectsToJson();
						drawMaskCanvas();
					}
				}
				if(event.key=="W"){
					if(isMaskMode==false){
						var listOfCornerVertices=[4,0,20,24];
						statesArray[globalController.selectedObject]["VerticeY"+listOfCornerVertices[selectedVertice]]=statesArray[globalController.selectedObject]["VerticeY"+listOfCornerVertices[selectedVertice]]+40;
						updateControlsView();
						syncObjectsToJson();
						displayObjects[globalController.selectedObject].updateCorners();
					}
					if(isMaskMode==true){
						maskHandleState[selectedMaskHandle].y=maskHandleState[selectedMaskHandle].y-20;
						syncObjectsToJson();
						drawMaskCanvas();
					}
				}
				if(event.key=="z"){
					if(statesArray[globalController.selectedObject].ZValue>-20){
						statesArray[globalController.selectedObject].ZValue=statesArray[globalController.selectedObject].ZValue-1;
						updateControlsView();
						syncObjectsToJson();
					}
				}
				if(event.key=="Z"){
					if(statesArray[globalController.selectedObject].ZValue<20){
						statesArray[globalController.selectedObject].ZValue=statesArray[globalController.selectedObject].ZValue+1;
						updateControlsView();
						syncObjectsToJson();
					}
				}			
				if(event.key=="X"){
					if(statesArray[globalController.selectedObject].Shader+1>2){
						statesArray[globalController.selectedObject].Shader=1;
					}else{
						statesArray[globalController.selectedObject].Shader=statesArray[globalController.selectedObject].Shader+1
					}
					updateControlsView();
					syncObjectsToJson();
				}
				if(event.key=="x"){
					if(statesArray[globalController.selectedObject].Shader-1<1){
						statesArray[globalController.selectedObject].Shader=2;
					}else{
						statesArray[globalController.selectedObject].Shader=statesArray[globalController.selectedObject].Shader-1
					}
					updateControlsView();
					syncObjectsToJson();
				}
				if(event.key=="v" || event.key=="V"){
					statesArray[globalController.selectedObject].Visible=!statesArray[globalController.selectedObject].Visible;
					updateControlsView();
					syncObjectsToJson();
				}
				if(event.key=="," ){
					if(isMaskMode==false){
						if( (selectedVertice-1)>=0){
							selectedVertice=selectedVertice-1;
						}else{
							selectedVertice=3;
						}
						highlightSelectedVertice();
					}
					if(isMaskMode==true){
						if( (selectedMaskHandle-1)>=0){
							selectedMaskHandle=selectedMaskHandle-1;
						}else{
							selectedMaskHandle=numMaskHandles-1;
						}
						highlightSelectedMaskHandle();
					}
				}
				if(event.key=="." ){
					if(isMaskMode==false){
						selectedVertice=(selectedVertice+1)%4;
						highlightSelectedVertice();
					}
					if(isMaskMode==true){
						selectedMaskHandle=(selectedMaskHandle+1)%numMaskHandles;
						highlightSelectedMaskHandle();
					}
				}
				keyPressToSlider(event, "0", globalController, "MaskA", 1, gui.__folders.Global, function(){ changeMask(1); updateControlsValues(); } );
				keyPressToSlider(event, ")", globalController, "MaskA", -1, gui.__folders.Global, function(){ changeMask(1); updateControlsValues(); } );
				keyPressToSlider(event, "p", globalController, "MaskB", 1, gui.__folders.Global, function(){changeMask(2); updateControlsValues(); } );
				keyPressToSlider(event, "P", globalController, "MaskB", -1, gui.__folders.Global, function(){changeMask(2); updateControlsValues(); } );
				keyPressToSlider(event, "k", globalController, "DMX_Pattern", 1, gui.__folders.DMX, function(){updateControlsValues(); } );
				keyPressToSlider(event, "K", globalController, "DMX_Pattern", -1, gui.__folders.DMX, function(){updateControlsValues(); } );
				keyPressToSlider(event, "j", globalController, "DMX_Brightness", .05, gui.__folders.DMX, function(){ updateControlsValues();  } );
				keyPressToSlider(event, "J", globalController, "DMX_Brightness", -.05, gui.__folders.DMX, function(){ updateControlsValues();  } );
				keyPressToSlider(event, "i", globalController, "DMX_Pattern_Rate", .05, gui.__folders.DMX, function(){ updateControlsValues();  } );
				keyPressToSlider(event, "I", globalController, "DMX_Pattern_Rate", -.05, gui.__folders.DMX, function(){ updateControlsValues();  } );
				if(event.key=="u"){
					if(globalController.DMX_Fade_Time+.025>1.0){
						globalController.DMX_Fade_Time=0.0;
						
					}else{
						globalController.DMX_Fade_Time=globalController.DMX_Fade_Time+.025;
					}
					gui.__folders.DMX.__controllers[4].updateDisplay();
					updateControlsValues();
				}
				if(event.key=="U"){
					if(globalController.DMX_Fade_Time-.025>0){
						globalController.DMX_Fade_Time=globalController.DMX_Fade_Time-.025;
					}else{
						globalController.DMX_Fade_Time=1.0;
					}
					gui.__folders.DMX.__controllers[4].updateDisplay();
					updateControlsValues();
				}			
				if(event.key=="!"){
					globalController.PresetName="GlobalPreset1";
					gui.__folders.Utils.__controllers.filter(obj => { return obj.property == "PresetName"})[0].updateDisplay();
					saveState();
				}
				if(event.key=="1"){
					globalController.PresetName="GlobalPreset1";
					gui.__folders.Utils.__controllers.filter(obj => { return obj.property == "PresetName"})[0].updateDisplay();
					recallState();
				}
				if(event.key=="@"){
					globalController.PresetName="GlobalPreset2";
					gui.__folders.Utils.__controllers.filter(obj => { return obj.property == "PresetName"})[0].updateDisplay();
					saveState();
				}
				if(event.key=="2"){
					globalController.PresetName="GlobalPreset2";
					gui.__folders.Utils.__controllers.filter(obj => { return obj.property == "PresetName"})[0].updateDisplay();
					recallState();
				}
				if(event.key=="#"){
					globalController.PresetName="GlobalPreset3";
					gui.__folders.Utils.__controllers.filter(obj => { return obj.property == "PresetName"})[0].updateDisplay();
					saveState();
				}
				if(event.key=="3"){
					globalController.PresetName="GlobalPreset3";
					gui.__folders.Utils.__controllers.filter(obj => { return obj.property == "PresetName"})[0].updateDisplay();
					recallState();
				}			
				if(event.key=="$"){
					globalController.PresetName="GlobalPreset4";
					gui.__folders.Utils.__controllers.filter(obj => { return obj.property == "PresetName"})[0].updateDisplay();
					saveState();
				}
				if(event.key=="4"){
					globalController.PresetName="GlobalPreset4";
					gui.__folders.Utils.__controllers.filter(obj => { return obj.property == "PresetName"})[0].updateDisplay();
					recallState();
				}				
				if(event.key=="%"){
					globalController.PresetName="GlobalPreset5";
					gui.__folders.Utils.__controllers.filter(obj => { return obj.property == "PresetName"})[0].updateDisplay();
					saveState();
					clonePreset5(6);
				}
				if(event.key=="5"){
					globalController.PresetName="GlobalPreset5";
					gui.__folders.Utils.__controllers.filter(obj => { return obj.property == "PresetName"})[0].updateDisplay();
					recallState();
				}					
				if(event.key=="n"){
					globalController.mappingMode=parseInt(globalController.mappingMode+1)%2;
					if(statesArray[globalController.selectedObject]["Visible"]==true){displayObjects[globalController.selectedObject].hideChildren();displayObjects[globalController.selectedObject].showChildren();};
				}
				keyPressToSlider(event, "6", globalController, "DMX_X1", 1, gui.__folders.DMX, function(){ updateControlsValues(); } );
				keyPressToSlider(event, "^", globalController, "DMX_X1", -1, gui.__folders.DMX, function(){ updateControlsValues(); } );
				keyPressToSlider(event, "7", globalController, "DMX_Y1", 1, gui.__folders.DMX, function(){ updateControlsValues(); } );
				keyPressToSlider(event, "&", globalController, "DMX_Y1", -1, gui.__folders.DMX, function(){ updateControlsValues(); } );
				keyPressToSlider(event, "8", globalController, "DMX_X2", 1, gui.__folders.DMX, function(){ updateControlsValues(); } );
				keyPressToSlider(event, "*", globalController, "DMX_X2", -1, gui.__folders.DMX, function(){ updateControlsValues(); } );
				keyPressToSlider(event, "9", globalController, "DMX_Y2", 1, gui.__folders.DMX, function(){ updateControlsValues(); } );
				keyPressToSlider(event, "(", globalController, "DMX_Y2", -1, gui.__folders.DMX, function(){ updateControlsValues(); } );
				keyPressToSlider(event, "l", globalController, "ShaderA", 1, gui.__folders.Global, function(){loadShaderPreset(1); updateControlsValues(); } );
				keyPressToSlider(event, "L", globalController, "ShaderA", -1, gui.__folders.Global, function(){loadShaderPreset(1); updateControlsValues(); } );
				keyPressToSlider(event, "o", globalController, "ShaderB", 1, gui.__folders.Global, function(){loadShaderPreset(2); updateControlsValues(); } );
				keyPressToSlider(event, "O", globalController, "ShaderB", -1, gui.__folders.Global, function(){loadShaderPreset(2); updateControlsValues(); } );
				keyPressToSlider(event, "t", globalController, "VolumeThreshold", .00025,  gui.__folders.Global, function(){ updateControlsValues(); } );
				keyPressToSlider(event, "T", globalController, "VolumeThreshold", -.00025, gui.__folders.Global, function(){updateControlsValues(); } );
				// keyPressToSlider(event, "f", globalController, "Camera_X", .01,  gui.__folders.Global, function(){ camera.position.x=globalController.Camera_X*window.innerWidth/3; updateControlsValues(); } );
				// keyPressToSlider(event, "F", globalController, "Camera_X", -.01, gui.__folders.Global, function(){ camera.position.x=globalController.Camera_X*window.innerWidth/3; updateControlsValues(); } );
				// keyPressToSlider(event, "g", globalController, "Camera_Y", .01,  gui.__folders.Global, function(){ camera.position.y=globalController.Camera_Y*window.innerHeight/3; updateControlsValues(); } );
				// keyPressToSlider(event, "G", globalController, "Camera_Y", -.01, gui.__folders.Global, function(){ camera.position.y=globalController.Camera_Y*window.innerHeight/3; updateControlsValues(); } );
				keyPressToSlider(event, "u", globalController, "BrightnessA", .1, gui.__folders.Global, function(){updateControlsValues(); } );
				keyPressToSlider(event, "U", globalController, "BrightnessA", -.1, gui.__folders.Global, function(){updateControlsValues(); } );
				keyPressToSlider(event, "y", globalController, "BrightnessB", .1, gui.__folders.Global, function(){updateControlsValues(); } );
				keyPressToSlider(event, "Y", globalController, "BrightnessB", -.1, gui.__folders.Global, function(){updateControlsValues(); } );
				if(event.key=='"'){
					rebootPi();
				}
				if(event.key=='|'){
					window.location.replace("http://"+location.hostname+"/FlowMapper.html");
				}
				if(event.key==";"){
					initStandaloneMode();
				}
				if(event.key=="'"){
					initControllerMode();
				}
				if(event.key==":"){
					initSlaveMode();
				}
				if(event.key=="m"){
					if(isMaskMode==false){
						toggleMaskMode("mask");
					}else{
						toggleMaskMode("map");
					}
				}
				if(event.key=="M"){
					if(isMaskMode==false){
						toggleMaskMode("mask");
					}else{
						toggleMaskMode("map");
					}
				}
				if(event.key=="R"){
					resetMaskHandles();
				}
			}

			function clonePreset5(destinationPresetNumber){
				if(destinationPresetNumber<9){
					var requestBody=JSON.stringify({"storage" : statesArray, "global": globalState, "maskHandles":maskHandleState})
					var xmlhttp=new XMLHttpRequest();
					xmlhttp.open("POST", "php/write.php?fn=globalPresets/GlobalPreset"+destinationPresetNumber+".txt", true);
					xmlhttp.send(requestBody);
					xmlhttp.onload = function(e){
						clonePreset5(destinationPresetNumber+1);
					}
				}
			}

			function toggleDmxSend(){
				if(globalController.SendDMX==true){
					clearInterval(dmxInterval);
					dmxInterval=setInterval(writeDMX,globalController.DMX_Rate);
				}else{
					clearInterval(dmxInterval);
				}
			}
			
			function writeDMX() {
				var xhttp = new XMLHttpRequest();
				xhttp.onreadystatechange = function() {
					if (this.readyState == 4 && this.status == 200) {
						console.log("Send DMX: "+this.responseText);
					}
				};
				xhttp.open("POST","proxy/set_dmx", true);
				xhttp.setRequestHeader("accept", "*/*");
				xhttp.setRequestHeader("accept-language", "en-US,en;q=0.9,und;q=0.8");
				xhttp.setRequestHeader("cache-control", "no-cache");
				xhttp.setRequestHeader("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
				xhttp.setRequestHeader("pragma", "no-cache" );

				var DMX_BrightnessAdjustedDMXData=[];
				for(var x=0; x<ledStripPatternsArray[parseInt(globalController.DMX_Pattern)-1][parseInt(ledStripAnimationmMasterIndex)].length ; x++){
					var oneValue=ledStripPatternsArray[parseInt(globalController.DMX_Pattern)-1][parseInt(ledStripAnimationmMasterIndex)][x];
					var isGuardedChannel=false;
					for(var y=0; y<listOfGuardedChannels.length; y++){
						if(x  == (listOfGuardedChannels[y]-1) ){
							isGuardedChannel=true;
						}
					}
					if(isGuardedChannel){
						if(x==(listOfGuardedChannels[0]-1)){
							DMX_BrightnessAdjustedDMXData.push(parseInt(globalController.DMX_X1));
						}
						if(x==(listOfGuardedChannels[1]-1)){
							DMX_BrightnessAdjustedDMXData.push(parseInt(globalController.DMX_Y1));
						}
						if(x==(listOfGuardedChannels[2]-1)){
							DMX_BrightnessAdjustedDMXData.push(parseInt(globalController.DMX_X2));
						}
						if(x==(listOfGuardedChannels[3]-1)){
							DMX_BrightnessAdjustedDMXData.push(parseInt(globalController.DMX_Y2));
						}
						
					}else{
						DMX_BrightnessAdjustedDMXData.push(parseInt(parseInt(oneValue)*globalController.DMX_Brightness));
					}
				}
				var DMX_BrightnessAdjustedDMXDataString=DMX_BrightnessAdjustedDMXData.toString();

				dmxPayloadString="u="+parseInt(globalController.Universe)+"&d="+DMX_BrightnessAdjustedDMXDataString+"0";
				// console.log(dmxPayloadString);
				xhttp.send(dmxPayloadString);
			}	

			function initializeDMX() {
				xhttp = new XMLHttpRequest();
				xhttp.onreadystatechange = function() {
					if (this.readyState == 4 && this.status == 200) {
						console.log("Initialize DMX: "+this.responseText);
						toggleDmxSend();
					}else{
						clearInterval(dmxInterval);
						console.log("DMX Not Available");
					}
				};
				xhttp.open("GET","proxy/reload", true);
				xhttp.send();
			}
				
			function keyPressToSlider(event, key, controller, slider, delta, folder, callback){
				if(event.key==key){
					var sliderMax=folder.__controllers.filter(obj => { return obj.property == slider})[0].__max;
					var sliderMin=folder.__controllers.filter(obj => { return obj.property == slider})[0].__min;
					if(controller[slider]+delta<=sliderMax && controller[slider]+delta>=sliderMin){
						controller[slider]=controller[slider]+delta;
					}else{
						if(controller[slider]+delta>sliderMax){
							controller[slider]=sliderMax;
						}
						if(controller[slider]+delta<sliderMin){
							controller[slider]=sliderMin;
						}
					}
					folder.__controllers.filter(obj => { return obj.property == slider})[0].updateDisplay();
					callback();
				}
			}
		
			function initAudio() {
				if(location.href.indexOf("localhost")!="-1"){
					console.log("trying audio");
					navigator.getUserMedia = navigator.getUserMedia
									|| navigator.webkitGetUserMedia
									|| navigator.mozGetUserMedia;

					navigator.getUserMedia({ video : false, audio : true }, getAudioData, console.log);

					function getAudioData(stream) {
						var ctx = new AudioContext();
						var mic = ctx.createMediaStreamSource(stream);
						var analyser = ctx.createAnalyser();

						mic.connect(analyser); 
						audioData = new Uint8Array(analyser.frequencyBinCount);
						function play() {
							analyser.getByteFrequencyData(audioData);
							//console.log(audioData);
							requestAnimationFrame(play);
						}

						play();
					}
				}else{
					console.log("audio only supported on localhost (without tls)");
					audioData = new Uint8Array(8);
				}
			}
			
            function getNumberOfShadersAndPresets(){
				var xmlhttp=new XMLHttpRequest();
				xmlhttp.open("GET", "../php/read.php?fn=fragmentShaders/numberOfShaders.txt", true);
				xmlhttp.send();
				xmlhttp.onload = function(e){
                    numberOfShaders=parseInt(xmlhttp.response);
                    console.log("get number of shaders: "+numberOfShaders)
                    gui.__folders.Global.__controllers.filter(obj => { return obj.property == "ShaderA"})[0].__max=numberOfShaders;
                    gui.__folders.Global.__controllers.filter(obj => { return obj.property == "ShaderA"})[0].updateDisplay()
                    gui.__folders.Global.__controllers.filter(obj => { return obj.property == "ShaderB"})[0].__max=numberOfShaders;
                    gui.__folders.Global.__controllers.filter(obj => { return obj.property == "ShaderB"})[0].updateDisplay()
                    gui.__folders.DMX.__controllers.filter(obj => { return obj.property == "DMX_Pattern"})[0].__max=numberOfShaders;
                    gui.__folders.DMX.__controllers.filter(obj => { return obj.property == "DMX_Pattern"})[0].updateDisplay()					
				}
				var xmlhttp2=new XMLHttpRequest();
				xmlhttp2.open("GET", "../php/read.php?fn=dmxPresets/numberOfPatterns.txt", true);
				xmlhttp2.send();
				xmlhttp2.onload = function(e){
                    numberOfDMXPatterns=parseInt(xmlhttp2.response);
                    console.log("get number of dmx patterns: "+numberOfDMXPatterns)
                    gui.__folders.DMX.__controllers.filter(obj => { return obj.property == "DMX_Pattern"})[0].__max=numberOfDMXPatterns;
                    gui.__folders.DMX.__controllers.filter(obj => { return obj.property == "DMX_Pattern"})[0].updateDisplay()					
				}
				var xmlhttp3=new XMLHttpRequest();
				xmlhttp3.open("GET", "../php/read.php?fn=masks/numberOfMasks.txt", true);
				xmlhttp3.send();
				xmlhttp3.onload = function(e){
                    numberOfMasks=parseInt(xmlhttp3.response);
                    console.log("get number of masks: "+numberOfMasks)
                    gui.__folders.Global.__controllers.filter(obj => { return obj.property == "MaskA"})[0].__max=parseInt(1+numberOfMasks);
                    gui.__folders.Global.__controllers.filter(obj => { return obj.property == "MaskA"})[0].updateDisplay()			
                    gui.__folders.Global.__controllers.filter(obj => { return obj.property == "MaskB"})[0].__max=parseInt(1+numberOfMasks);
                    gui.__folders.Global.__controllers.filter(obj => { return obj.property == "MaskB"})[0].updateDisplay()					
				}
				var xmlhttp4=new XMLHttpRequest();
				xmlhttp4.open("GET", "../php/read.php?fn=dmxPresets/pattern0.txt", true);
				xmlhttp4.send();
				xmlhttp4.onload = function(e){
                    listOfGuardedChannels=xmlhttp4.response.split(",");
					for (var x=0; x<listOfGuardedChannels.length; x++){
						listOfGuardedChannels[x]=parseInt(listOfGuardedChannels[x]);
					}
                    console.log("get list of guarded channels: "+listOfGuardedChannels)				
				}
            }
		
			function getCanvasYFlip(){
				var xmlhttp=new XMLHttpRequest();
				xmlhttp.open("GET", "php/read.php?fn=misc/canvasYFlip.txt", true);
				xmlhttp.send();
				xmlhttp.onload = function(e){
					var yFlipValue=parseInt(xmlhttp.response);
					console.log("Got Y Flip Value: "+yFlipValue);
					document.getElementsByTagName('canvas')[0].style.transform='scale(1,'+yFlipValue+')';
				}
			}
		
			function rebootPi(){
				var xmlhttp=new XMLHttpRequest();
				xmlhttp.open("GET", "../php/reboot.php", true);
				xmlhttp.send();
				xmlhttp.onload = function(e){console.log(xmlhttp.response.status)}
			}
		
			function highlightSelectedVertice(){
				var listOfCornerVertices=[4,0,20,24];
				for(var y=0; y<displayObjects.length; y++){
					for(var x=0; x<4; x++){
						if(parseInt(x)==parseInt(selectedVertice)){
							displayObjects[y].children[listOfCornerVertices[x]].material.color={"r":1.0, "g":0.0, "b":1.0}
						}else{
							displayObjects[y].children[listOfCornerVertices[x]].material.color={"r":1.0, "g":1.0, "b":1.0}
						}
					}
				}
				syncObjectsToJson();
			}

			function highlightSelectedMaskHandle(){
				for(var x=0; x<maskHandleObjects.length; x++){
					if(parseInt(x)==parseInt(selectedMaskHandle)){
						maskHandleObjects[x].material.color={"r":1.0, "g":0.0, "b":1.0}
					}else{
						maskHandleObjects[x].material.color={"r":1.0, "g":1.0, "b":1.0}
					}
				}
			}

			function setCurrentApp(appInitials){
				var xmlhttp=new XMLHttpRequest();
				xmlhttp.open("POST", "php/write.php?fn=globalPresets/currentApp.txt", true);
				xmlhttp.send(appInitials);
				xmlhttp.onload = function(e){
					console.log("setCurrentApp:"+appInitials);
					getCurrentApp();
				}
			}
			
			function getCurrentApp(){
				var xmlhttp=new XMLHttpRequest();
				xmlhttp.open("GET", "php/read.php?fn=globalPresets/currentApp.txt", true);
				xmlhttp.send();
				xmlhttp.onload = function(e){
					currentApp=xmlhttp.response;
					// console.log("getCurrentApp:"+xmlhttp.response);
					// if(currentApp=="fm" && slaveModeInterval!=-1){
					if(currentApp=="fm"){
						window.location.replace("http://"+location.hostname+"/FlowMapper.html");
					}else{
						setTimeout(function(){
							getCurrentApp();
							getShadersNeedReload();
						},3000);
					}
				}
			}

			function getShadersNeedReload(){
				var xmlhttp=new XMLHttpRequest();
				xmlhttp.open("GET", "php/read.php?fn=globalPresets/shadersNeedReload.txt", true);
				xmlhttp.send();
				xmlhttp.onload = function(e){
					if(xmlhttp.response=="true"){
						loadShaderPreset(1);
						loadShaderPreset(2);
						console.log("reload shaders");
						resetShadersNeedReload();
					}
				}
			}

			function resetShadersNeedReload(){
				var requestBody="false";
				var xmlhttp=new XMLHttpRequest();
				xmlhttp.open("POST", "php/write.php?fn=globalPresets/shadersNeedReload.txt", true);
				xmlhttp.send(requestBody);
				xmlhttp.onload = function(e){
					console.log("Wrote 'false' to shadersNeedReload");
				}
			}
		
			function resetMaskHandles(){
				var xmlhttp=new XMLHttpRequest();
				xmlhttp.open("GET", "../php/read.php?fn=globalPresets/DefaultMaskData.txt", true);
				xmlhttp.send();
				xmlhttp.onload = function(e){
					var temp=JSON.parse(xmlhttp.response).maskHandles;
					for(var x=0; x<numMaskHandles; x++){
						temp[x].x=temp[x].x*maskControllerScalingFactor;
						temp[x].y=temp[x].y*maskControllerScalingFactor;
						}
					maskHandleState=temp;
					syncObjectsToJson();
					drawMaskCanvas();
				}
			}	
		</script>
	</body>
</html>

